About Fetch
============


Introduction
----------------

Fetch is a script designed to collect market-related data on cryptocurrencies, including 
Bitcoin and Ethereum. It uses an SQLite3 database for storage and excels at time consistency. 
By leveraging the power of asynchronous programming, Fetch efficiently harnesses threading to
deliver precise and optimized operations. 

How it works
----------------

Fetch is an asynchronous program running through a main event loop. It uses the `asyncio` 
module to run tasks concurrently within the `main()` function. This means that the 
program continuously executes functions instead of processing them sequentially. Asynchronous 
operations occur inside the `gather()` function of the `main()` loop.

How it fetches and writes to the database
-----------------------------------------------

There are three main functions responsible for fetching data:

 - `fetch_coindata()`,  `fetch_marketdata()`,  and  `fetch_sentiment()`. 

They use a core function named `fetch_data_with_retry()` to handle their requests. They are 
also managed by three scheduled coroutines:

 - `fetch_stack()` runs every five minutes and concurrently calls `fetch_coindata()` and 
   `fetch_marketdata()`

 - `hourly_sentiment()` and `daily_sentiment()` call `fetch_sentiment()` every hour 
   and every day, respectively.

> Note: `fetch_sentiment()` is the only fetching function that does not write to the database. Instead, it fetches data and stores it globally to save ressources. Values are then passed through the `fetch_marketdata()` function. 


Timing Accuracy and System Clock Drift
----------------------------------------

Although this application uses a precisely calibrated scheduler based on `time.monotonic()`,
you may occasionally observe discrepancies between expected and actual timestamp values when 
looking at entries in the database. This is not a fault of the schedulerâ€”it's a consequence of 
how operating systems handle wall-clock time. Most systems regularly synchronize their clocks 
using NTP `(Network Time Protocol)`. Over long runtimes, your system clock may gradually drift 
ahead or behind the actual time due to hardware imperfections. To correct this, the OS will 
occasionally step the system clock forward or backward, or slew it slowly back into alignment. 
These corrections can cause timestamps generated by `datetime.now()` to appear to jump, even 
though the underlying scheduler has continued running smoothly.To prevent accumulated timing 
drift and remain immune to system time adjustments, this application uses `time.monotonic()` as 
its reference clock. This clock: 

 - Always moves forward, never jumps backward or forward due to NTP or system changes
 - Is immune to daylight saving time, timezone changes, and manual user adjustments 
 - Provides consistent interval measurements, ideal for long-running scheduled tasks

By anchoring interval scheduling to monotonic time and separating it from timestamp generation,
we achieve high-precision task execution while remaining aware of occasional system clock 
corrections.


Fail-safe mechanisms
--------------------------

`fetch_data_with_retry()` is the core function responsible for making requests. It allows for 
up to five retries before giving up. If an attempt to fetch fails, it notifies the user. This 
prevents outdated or biased data from being inserted into the database and instead writes
`NULL` values. By using `time.monotonic()`, Fetch never loses time and ensures time measurements are always taken at the same exact 
second for every interval. Moreover, time measurements are always proceeded before `fetch_data_with_retry()`,
ensuring consistency even if attempts to fetch were made.

Database operations
------------------------

The database consists of three tables: `bitcoin_data`, `eth_data`, and `market_data`.
The database runs in **WAL (Write-Ahead Logging) mode**, allowing for efficient chunked data movements 
and optimizing performance. Time measures are taken in a DateTime format and stored in the column
"date" for each tables. These columns are indexed by default for faster access.

